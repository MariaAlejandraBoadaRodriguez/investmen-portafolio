# Quantum Portfolio Optimizer

This project implements a **full-stack system** for portfolio optimization using both classical and quantum methods.  
The **backend** is built with **FastAPI** and leverages **PennyLane** to simulate quantum algorithms such as **QAOA** and **VQA**, alongside a classical heuristic baseline (**Simulated Annealing**).


![alt text](./img/image-5.png)

---

## ğŸ”¹ Backend

The backend exposes a REST API that receives financial data (historical prices) and optimization parameters, and returns recommended portfolios generated by each method (SA, QAOA, VQA).

### âš™ï¸ Main Technologies
- [Python 3.10+](https://www.python.org/)
- [FastAPI](https://fastapi.tiangolo.com/)
- [Uvicorn](https://www.uvicorn.org/) (ASGI server)
- [Pandas](https://pandas.pydata.org/) and [NumPy](https://numpy.org/) for financial data processing
- [PennyLane](https://pennylane.ai/) and [Qiskit](https://qiskit.org/) for quantum algorithms
- [Scikit-learn](https://scikit-learn.org/) for PCA and classical utilities

### ğŸ“‚ Backend Structure
backend/
â”‚â”€â”€ app.py
â”‚â”€â”€ requirements.txt
â”‚â”€â”€ utils.py 
â”‚â”€â”€ quantum_methods/ # Implementations of SA, QAOA, VQA
â”‚ â”œâ”€â”€ sa.py
â”‚ â”œâ”€â”€ qaoa.py
â”‚ â””â”€â”€ vqa.py

### ğŸ§® Mathematical & Quantum Foundations

This project combines modern portfolio theory, discrete optimization, and quantum-inspired algorithms to solve the investment allocation problem under budget, return, and risk constraints.

1. Financial Statistics

    * Annualized Returns (Î¼)
    Computed from the log-returns of adjusted closing prices:

    ![alt text](./img/image.png)

    * Covariance Matrix (Î£):
    Estimated from the daily returns and scaled by 252 to reflect annual risk.

    ![alt text](./img/image-1.png)

    These form the basis for measuring expected return and risk

2. Preselection of Assets

To avoid combinatorial explosion when M (number of available assets) is large, we preselect exactly k assets using heuristics:
  
   * Sharpe ratio â†’ maximize risk-adjusted return.
   * High-return filter â†’ pick assets with largest Î¼
   * Low-volatility & correlation (default) â†’ pick assets that reduce redundancy and total variance.

3. QUBO Formulation

The portfolio allocation is cast as a Quadratic Unconstrained Binary Optimization (QUBO) problem.
Each asset i is represented with q binary variables encoding discrete weight units (binary expansion):

![alt text](./img/image-2.png)

Where:

* q: number of bits per asset
* B: total units available (budget granularity)
* bik : binary decision variables

Final objective:

![alt text](./img/image-3.png)

4. Solvers

The QUBO can be solved by:

* Simulated Annealing (SA) â†’ fast, classical stochastic optimization.
* Quantum Approximate Optimization Algorithm (QAOA) (via PennyLane) â†’ hybrid quantum-classical variational solver.
* Variational Quantum Algorithms (VQA) (future extension) â†’ explore richer ansatz beyond QAOA.

5. Interpretation of Results

The solution vector b is decoded into portfolio weights:

![alt text](./img/image-4.png)

where A is the binary expansion matrix.

The framework then outputs:

* Selected assets (tickers)
* Optimal weights (ğ‘¤ğ‘–)
* Investment amounts in USD
* Portfolio metrics (expected return, volatility, cost function ğ¶)

6. In summary

We translate the portfolio optimization problem into a binary combinatorial model (QUBO), which can be tackled by quantum-inspired heuristics or quantum algorithms. This bridges traditional finance with cutting-edge quantum optimization.

## ğŸ”¹ Frontend

### ğŸ¨ Frontend (Vite + React)

A lightweight SPA built with Vite + React that lets a user:

* Pick up to 7 tickers from the loaded universe
* Set an investment budget in USD
* Choose the discretization (q, B_units) and hyper-parameters (lam_risk, lam_ret, lam_budget)
* Run three solvers (SA, QAOA, VQA) via the backend and compare recommended allocations
* See per-model allocations, weights, USD amounts, and summary metrics (expected return, volatility, cost)

### ğŸ§± Tech Stack

* Vite for fast dev/build
* React 18 (functional components + hooks)
* Fetch API for HTTP calls
* Vanilla CSS (see styles.css) â€” easy to swap to Tailwind/Chakra later

### ğŸ“ Project Structure

frontend/
â”œâ”€ components/
â”‚  â”œâ”€ Controls.jsx     
â”‚  â”œâ”€ TickerGallery.jsx  
â”‚  â””â”€ Footer.jsx          
â”œâ”€ src/
â”‚  â”œâ”€ App.jsx             
â”‚  â””â”€ main.jsx          
â”œâ”€ styles.css         
â”œâ”€ index.html            
â”œâ”€ vite.config.js
â”œâ”€ package.json
â””â”€ .env / .env.production 

### â–¶ï¸ Run & Build

npm install
npm run dev      
npm run build    
npm run preview 

