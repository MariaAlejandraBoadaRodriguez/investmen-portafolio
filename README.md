# Quantum Portfolio Optimizer

This project implements a **full-stack system** for portfolio optimization using both classical and quantum methods.  
The **backend** is built with **FastAPI** and leverages **PennyLane** to simulate quantum algorithms such as **QAOA** and **VQA**, alongside a classical heuristic baseline (**Simulated Annealing**).


![alt text](./img/image-5.png)

---

## 🔹 Backend

The backend exposes a REST API that receives financial data (historical prices) and optimization parameters, and returns recommended portfolios generated by each method (SA, QAOA, VQA).

### ⚙️ Main Technologies
- [Python 3.10+](https://www.python.org/)
- [FastAPI](https://fastapi.tiangolo.com/)
- [Uvicorn](https://www.uvicorn.org/) (ASGI server)
- [Pandas](https://pandas.pydata.org/) and [NumPy](https://numpy.org/) for financial data processing
- [PennyLane](https://pennylane.ai/) and [Qiskit](https://qiskit.org/) for quantum algorithms
- [Scikit-learn](https://scikit-learn.org/) for PCA and classical utilities

### 📂 Backend Structure
backend/
│── app.py
│── requirements.txt
│── utils.py 
│── quantum_methods/ # Implementations of SA, QAOA, VQA
│ ├── sa.py
│ ├── qaoa.py
│ └── vqa.py

### 🧮 Mathematical & Quantum Foundations

This project combines modern portfolio theory, discrete optimization, and quantum-inspired algorithms to solve the investment allocation problem under budget, return, and risk constraints.

1. Financial Statistics

    * Annualized Returns (μ)
    Computed from the log-returns of adjusted closing prices:

    ![alt text](./img/image.png)

    * Covariance Matrix (Σ):
    Estimated from the daily returns and scaled by 252 to reflect annual risk.

    ![alt text](./img/image-1.png)

    These form the basis for measuring expected return and risk

2. Preselection of Assets

To avoid combinatorial explosion when M (number of available assets) is large, we preselect exactly k assets using heuristics:
  
   * Sharpe ratio → maximize risk-adjusted return.
   * High-return filter → pick assets with largest μ
   * Low-volatility & correlation (default) → pick assets that reduce redundancy and total variance.

3. QUBO Formulation

The portfolio allocation is cast as a Quadratic Unconstrained Binary Optimization (QUBO) problem.
Each asset i is represented with q binary variables encoding discrete weight units (binary expansion):

![alt text](./img/image-2.png)

Where:

* q: number of bits per asset
* B: total units available (budget granularity)
* bik : binary decision variables

Final objective:

![alt text](./img/image-3.png)

4. Solvers

The QUBO can be solved by:

* Simulated Annealing (SA) → fast, classical stochastic optimization.
* Quantum Approximate Optimization Algorithm (QAOA) (via PennyLane) → hybrid quantum-classical variational solver.
* Variational Quantum Algorithms (VQA) (future extension) → explore richer ansatz beyond QAOA.

5. Interpretation of Results

The solution vector b is decoded into portfolio weights:

![alt text](./img/image-4.png)

where A is the binary expansion matrix.

The framework then outputs:

* Selected assets (tickers)
* Optimal weights (𝑤𝑖)
* Investment amounts in USD
* Portfolio metrics (expected return, volatility, cost function 𝐶)

6. In summary

We translate the portfolio optimization problem into a binary combinatorial model (QUBO), which can be tackled by quantum-inspired heuristics or quantum algorithms. This bridges traditional finance with cutting-edge quantum optimization.

## 🔹 Frontend

### 🎨 Frontend (Vite + React)

A lightweight SPA built with Vite + React that lets a user:

* Pick up to 7 tickers from the loaded universe
* Set an investment budget in USD
* Choose the discretization (q, B_units) and hyper-parameters (lam_risk, lam_ret, lam_budget)
* Run three solvers (SA, QAOA, VQA) via the backend and compare recommended allocations
* See per-model allocations, weights, USD amounts, and summary metrics (expected return, volatility, cost)

### 🧱 Tech Stack

* Vite for fast dev/build
* React 18 (functional components + hooks)
* Fetch API for HTTP calls
* Vanilla CSS (see styles.css) — easy to swap to Tailwind/Chakra later

### 📁 Project Structure

frontend/
├─ components/
│  ├─ Controls.jsx     
│  ├─ TickerGallery.jsx  
│  └─ Footer.jsx          
├─ src/
│  ├─ App.jsx             
│  └─ main.jsx          
├─ styles.css         
├─ index.html            
├─ vite.config.js
├─ package.json
└─ .env / .env.production 

### ▶️ Run & Build

npm install
npm run dev      
npm run build    
npm run preview 

